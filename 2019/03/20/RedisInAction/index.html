<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Redis实战, lanchunqiu.github.io">
    <meta name="description" content="初识Redis一般来说，缓存可以分为两大类：

应用内缓存，比如Java的Map、Set等简单数据结构，以及Ehcache等三方库；
独立的缓存服务（组件），比如Memcached、Redis；

Redis（Remote Dictiona">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Redis实战 | lanchunqiu.github.io</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">lanchunqiu.github.io</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">lanchunqiu.github.io</div>
        <div class="logo-desc">
            
            欢迎访问我的博客小站
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/lanchunqiu" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/lanchunqiu" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Redis实战
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/" target="_blank">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                            <a href="/tags/Redis/" target="_blank">
                                <span class="chip bg-color">Redis</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Redis/" class="post-category" target="_blank">
                                Redis
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-03-20
                </div>

                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h2><p>一般来说，缓存可以分为两大类：</p>
<ul>
<li>应用内缓存，比如Java的Map、Set等简单数据结构，以及Ehcache等三方库；</li>
<li>独立的缓存服务（组件），比如Memcached、Redis；</li>
</ul>
<p>Redis（Remote Dictionary Server）远程字典服务器，它是一种基于key-value的高性能的存储系统，它提供了5种键值数据类型来适应不同场景下的缓存与存储需求。Redis是一种速度非常快的非关系数据库，它除了性能强劲之外还具有复制、持久化、分片、事物等特性，用户可以很方便地将Redis扩展成一个能够包含数百G数据、每秒处理上百万次请求的系统。</p>
<p>如下表Redis和其他一些非关系数据库的比较。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数据存储</th>
<th>特性</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Redis</td>
<td>内存存储非关系键值数据库</td>
<td>字符串、列表、散列、集合、有序集合</td>
<td>主从复制、持久化、分片、发布与订阅，Lua脚本</td>
<td></td>
</tr>
<tr>
<td>Memcached</td>
<td>内存存储键值缓存</td>
<td>键值关系映射</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MongoDB</td>
<td>硬盘存储非关系文档型数据库</td>
<td>BSON文档（类似json格式）</td>
<td>支持Map-Reduce操作、主从复制、分片、空间索引</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h2><p>Redis约定次版本号（第一个小数点后的数字）为偶数是稳定版本，例如2.8、3.0、3.2，次版本号为基数时是非稳定版本。</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li>下载Redis安装包，<a href="http://download.redis.io/releases/" target="_blank" rel="noopener">http://download.redis.io/releases/</a></li>
<li>tar -zxvf解压安装包;</li>
<li>cd到解压后的目录;</li>
<li>执行make编译;</li>
<li>测试编译状态， make test;</li>
<li>make install {prefix=/path/…/…}  安装;</li>
</ol>
<h3 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h3><p>Redis安装完成之后，会自动生成一些可执行文件：</p>
<ul>
<li><p><strong>redis-server</strong>：redis服务端</p>
</li>
<li><p><strong>redis-cli</strong>：redis命令行客户端</p>
</li>
<li><p><strong>redis-sentinel</strong>：sentinel服务（2.8以后）</p>
</li>
<li><p><strong>redis-check-rdb</strong>：rdb文件检查工具</p>
</li>
<li><p><strong>redis-check-aof</strong>：aof文件修复工具</p>
</li>
<li><p><strong>redis-benchmark</strong>：redis性能测试工具</p>
</li>
</ul>
<p>常用的命令是redis-server和redis-cli</p>
<p>1.启动服务</p>
<pre><code>redis-server /path/redis.conf
</code></pre><p>服务器启动后默认端口是6379，可以–port自定义端口。（6379在手机键盘上与MERZ对应，MERZ是一名意大利歌女的名字）如果想以守护进程的方式启动，需要修改redis.conf配置文件，把daemonize设置为yes。</p>
<p>2.停止服务</p>
<pre><code>redis-cli shutdown
</code></pre><p>考虑到Redis服务有可能正在将内存的数据同步到磁盘中，强行终止Redis进程可能会导致数据丢失，正确停止Redis的方式是向Redis发送shutdown命令。当Redis服务收到shutdown命令后，会先断开所有客户端连接，然后根据配置进行持久化，最终完成退出。</p>
<h2 id="数据结构类型"><a href="#数据结构类型" class="headerlink" title="数据结构类型"></a>数据结构类型</h2><p>Redis可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为字符串（string），列表（list），集合（set），有序集合（zset），哈希（hash）。</p>
<p><strong>Redis提供的5种数据结构类型</strong></p>
<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>可以是字符串、整数或浮点数</td>
<td>对整个字符串或字符串的一部分支线操作；对整数和浮点数执行自增（increment）或自减（decrement）操作</td>
</tr>
<tr>
<td>LIST</td>
<td>一个链表，链表上的每个节点都包含了一个字符串</td>
<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或者多个元素；根据值查找或者移除元素</td>
</tr>
<tr>
<td>SET</td>
<td>包含字符串的无序收集器，并且被字符串不能重复，各不相同</td>
<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机取元素</td>
</tr>
<tr>
<td>ZSET</td>
<td>字符成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td>
<td>添加、获取、删除单个元素；根据分值范围或者成员来获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对；获取所以键值对</td>
</tr>
</tbody>
</table>
<h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><p>字符串(string)类型是redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。可以用它来存储用户的邮箱、json化对象、甚至是图片。一个字符串类型键允许存储的最大容量是512M。</p>
<h4 id="内部数据结构"><a href="#内部数据结构" class="headerlink" title="内部数据结构"></a>内部数据结构</h4><p>在Redis内部，String类型通过int、sds(simple dynamic string)作为存储结构，int用来存放整型数据，sds存放字节、字符串、浮点型数据。在C的标准字符串结构下进行了封装，用来提升基本操作的性能，同时也充分利用已有的C标准库，简化实现逻辑。可以在Redis的源码中[sds.h]中看到的结构如下：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>sds<span class="token punctuation">;</span>
</code></pre>
<p>redis3.2版本之后引入了5种sdshdr类型，目的是为了满足不同长度字符串可以使用不同大小的sdshdr，从而节省内存，每次创建一个sds时根据sds的实际长度判断应该选择什么类型的sdshdr。sdshdr的5中结构定义如下：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */</span>
<span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr5 <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, and 5 msb of string length */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr8 <span class="token punctuation">{</span>
    uint8_t len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* used */</span>
    uint8_t alloc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr16 <span class="token punctuation">{</span>
    uint16_t len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* used */</span>
    uint16_t alloc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr32 <span class="token punctuation">{</span>
    uint32_t len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* used */</span>
    uint32_t alloc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr64 <span class="token punctuation">{</span>
    uint64_t len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* used */</span>
    uint64_t alloc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>以sdshdr8为例，来解释一下，8表示字符串最大长度是<code>2^8-1</code>即255</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr8 <span class="token punctuation">{</span>
    uint8_t len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//表示当前sds的长度(单位是字节)</span>
    uint8_t alloc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//表示sds已分配内存大小(单位是字节)</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用一个字节表示当前sdshdr的类型，应为sdshdr有5种类型，所以至少需要3位来表示：000--sdshdr5、001--shshdr8、010--sdshdr16、011--sdshdr32、100--sdshdr64，高5位用不到所以都是0</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字节数据，用于保存字符串</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><img src="/2019/03/20/RedisInAction/sdshdr8.png" alt></p>
<p>SDS遵循C字符串以空字符结尾的惯例。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ol>
<li><p><strong>append</strong>： append key value； 如果key已经存在并且是一个字符串，append命令将value追加到原理值得末尾。可用版本&gt;=2.0.0。</p>
</li>
<li><p><strong>bitcount</strong>：bitcount key [start end]； 统计字符串中，被设置为1的比特位的数量。可用版本&gt;=2.6.0。</p>
</li>
<li><p><strong>bitop</strong>：bitop operation destkey key [key …] ；对一个或多个保存二进制位的字符串key进行位元操作，并将结果保存到destkey上。operation可以是AND、OR、NOT、XOR这四种操作中的任意一种。可用版本&gt;=2.6.0。</p>
</li>
<li><p><strong>decr</strong>：decr key ；将key中存储的数据值减1。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>decrby</strong>：decrby key decrement；将key所存储的值减去decrement。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>get</strong>：get key；返回Key所对应的支付串的值。如果 key不存在那么返回特殊值 nil 。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>getbit</strong>：getbit key offset；对key所存储的字符串值，获取指定偏移量上的位(bit)。可用版本&gt;=2.2.0。</p>
</li>
<li><p><strong>getrange</strong>：getrange key start end；截取得出子字符串。可用版本&gt;=2.4.0</p>
</li>
<li><p><strong>getset</strong>：getset key value；将给定key的值设为value，并返回key的旧值。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>incr</strong>：incr key；将key中存储的数字值增一。可用版本&gt;=1.0.0</p>
</li>
<li><p><strong>incrby</strong>：incrby key increment；将key所存储的值加上增量increment。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>incrbyfloat</strong>：incrbyfloat key increment；为key中所存储的值加上浮点数增量increment。可用版本&gt;=2.6.0</p>
</li>
<li><p><strong>mget</strong>：mget key [key …] ；返回所有(一个或多个)给定key的值。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>mset</strong>：mset key value [key value …] ；同时设置一个或多个key-value对。可用版本&gt;=1.0.1</p>
</li>
<li><p><strong>msetnx</strong>：msetnx key value [key value …]； 同时设置一个或多个key-value对，当且仅当所有给定的key都不存在。可用版本&gt;=1.0.1。</p>
</li>
<li><p><strong>psetnx</strong>：psetnx key milliseconds value； 这个命令和setex命令相识，但它以毫秒为单位设置key的生存时间，而不是像setex命令那样，以秒为单位。可用版本&gt;=2.6.0。</p>
</li>
<li><p><strong>set</strong>：set key value [EX seconds] [PX milliseconds] [NX|XX]；将字符串value关联到key。可用版本&gt;=1.0.0。</p>
<p>从版本2.6.12开始，set命令的行为可以通过一系列参数来修改：</p>
<ul>
<li><p>EX seconds:设置键的过期时间为second秒，set key value ex second 效果等同于setex key second value；</p>
</li>
<li><p>PX milliseconds:设置键的过期时间为millisecond毫秒。set key value px millisecond效果等同于psetex key millisecond value；</p>
</li>
<li>NX:只有键不存在时，才对键进行设置操作，set key value nx 效果等同于setnx key value；</li>
<li>XX:只在键已经存在时，才对键进行设置操作。</li>
</ul>
</li>
<li><p><strong>setbit</strong>：setbit key offset value；对key所存储的字符串值，设置或清除指定偏移量上的位(bit)。可用版本&gt;=2.2.0。</p>
</li>
<li><p><strong>setex</strong>：setex key seconds value；将值value关联到key，并将key的生存时间设置为seconds秒。可用版本&gt;=2.0.0。</p>
</li>
<li><p><strong>setnx</strong>：setnx key value；将key的值设为value，当且仅当key不存在。设置成功，返回1；设置失败，返回0。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>setrange</strong>：setrange key offset value；用value覆盖给定key所存在的字符串值，从偏移量offset开始。可用版本&gt;=2.2.0。</p>
</li>
<li><p><strong>strlen</strong>：strlen key；返回key所存储的字符串值得长度。可用版本&gt;=2.2.0。</p>
</li>
</ol>
<h3 id="列表-List"><a href="#列表-List" class="headerlink" title="列表(List)"></a>列表(List)</h3><p>列表(list)类型可以存储一个有序的字符串列表，常用的操作是向列表的两端添加元素或者获取列表的某个片段。</p>
<p> 列表类型使用双向链表实现的，所以向列表两端添加元素的时间复制度为O(1)，获取越接近两端的元素就越快。</p>
<h4 id="内部数据结构-1"><a href="#内部数据结构-1" class="headerlink" title="内部数据结构"></a>内部数据结构</h4><p>在redis3.2之前的版本，列表类型的value对象内部是以linkedlist或ziplist来实现，当列表只包含少量元素，并且每个元素要么是小整数值，要么是长度📒短的字符串时，Redis就会使用压缩链表(zpilist)来存储来节省内存，否则将会采用双向链表（linkedlist）存储。双向链表的节点结构可以在redis源码的<code>adlist.h</code>看到，listNode具体结构定义如下：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> listNode <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> listNode <span class="token operator">*</span>prev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//前置节点</span>
    <span class="token keyword">struct</span> listNode <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//后置节点</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//节点的值</span>
<span class="token punctuation">}</span> listNode<span class="token punctuation">;</span>
</code></pre>
<p>虽然可以使用多个listNode结构就能组成链表，但是使用一个list来持有链表的化，操作会更方便，list具体结构定义如下：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> list <span class="token punctuation">{</span>
    listNode <span class="token operator">*</span>head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表头节点</span>
    listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表尾节点</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点复制函数</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点释放函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点对比函数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表包含的节点数量</span>
<span class="token punctuation">}</span> list<span class="token punctuation">;</span>
</code></pre>
<p>列表的这两种存储方式各有优缺点：</p>
<ul>
<li>双向链表在链表的两端进行添加和删除操作，时间复查度低，但内存开销大；</li>
<li>压缩链表存储在一段连续的内存上，所以存储效率高，但是插入和删除都要频繁申请和释放内存；</li>
</ul>
<p>在redis3.2之后的版本，采用了一种叫quicklist的数据结构来存储列表类型的value值，quicklist结构参见Redis源码<code>quicklist.h</code>，quicklistNode的结构定义如下：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.
 * We use bit fields keep the quicklistNode at 32 bytes.
 * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).
 * encoding: 2 bits, RAW=1, LZF=2.
 * container: 2 bits, NONE=1, ZIPLIST=2.
 * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.
 * attempted_compress: 1 bit, boolean, used for verifying during testing.
 * extra: 12 bits, free for future use; pads out the remainder of 32 bits */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> quicklistNode <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> quicklistNode <span class="token operator">*</span>prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前置节点</span>
    <span class="token keyword">struct</span> quicklistNode <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//后置节点</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ziplist节点</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/* ziplist size in bytes */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* count of items in ziplist */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* RAW==1 or LZF==2 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* NONE==1 or ZIPLIST==2 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* was this node previous compressed? */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* node can't compress; too small */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> extra <span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* more bits to steal for future usage */</span>
<span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span>
</code></pre>
<p>可以从上面的结构定义看出，quicklist本质任然是一个双向链表，只是在列表的每个节点都是一个ziplist,其实就是linkedlist和ziplist的结合，quicklist中每个节点ziplist都能够存储多个数据元素，在源码中的文件为<code>quicklist.c</code>的第一行就有这样的描述：quicklist.c - A doubly linked list of ziplists意思是quicklist就是有ziplist组成的双向链表。</p>
<p><img src="/2019/03/20/RedisInAction/quicklist.png" alt></p>
<h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><ol>
<li><p><strong>blpop</strong>：blpop key [key …] timeout；blpop是列表阻塞式(blocking)弹出原语。它是lpop命令的阻塞版本，当给定列表没有任何元素可供弹出的时候，连接将被blpop命令阻塞，直到等待超时或发现可弹元素为止。超时参数 <code>timeout</code> 接受一个以秒为单位的数字作为值。超时参数设为 <code>0</code> 表示阻塞时间可以无限期延长(block indefinitely) 。可用版本&gt;=2.0.0。</p>
</li>
<li><p><strong>brpop</strong>：brpop key [key …] timeout；brpop是列表的阻塞式(blocking)弹出原语。它是 rpop命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被brpop命令阻塞，直到等待超时或发现可弹出元素为止。可用版本&gt;2.0.0。</p>
</li>
<li><p><strong>brpoplpush</strong>：brpoplpush source destination timeout；brpoplpush是rpoplpush的阻塞版本，当给定列表source不为空时，brpoplpush的表现和rpoplpush一样。当列表source为空时brpoplpush命令将阻塞连接，直到等待超时，或有另一个客户端多source执行lpush或rpush命令为止。可用版本&gt;=2.2.0。</p>
</li>
<li><p><strong>lindex</strong>：lindex key index；返回列表key中，下标为index的元素。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>linsert</strong>：linsert key before|after pivot value；将值value插入到列表key中，位于值prvot之前或之后。可用版本&gt;2.2.0。</p>
</li>
<li><p><strong>llen</strong>：llen key；返回列表key的长度。  如果key不存在，则key被解释为一个空列表，返回0。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>lpop</strong>：lpop key；移除并返回列表key的头元素。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>lpush</strong>：lpush key value [value …]；将一个或多个value插入到列表key的表头。如果有多个value值，那么各个value值按从左到右的顺序依次插入到表头。执行lpush后返回列表的长度。可用版本&gt;=1.0.0。</p>
</li>
<li><p><strong>lpushx</strong>：lpushx key value；将值value插入到列表key的表头，当且仅当key存在并且是一个列表。当key不存在时，lpushx命令什么也不做。lpushx命令执行后，返回列表的长度。可用版本&gt;=2.2.0。</p>
</li>
<li><p>lrange：lrange key start stop；返回列表key中指定区间内的元素，区间以偏移量start和stop指定。下标参数start和end都是以0开始，也就是说，以0表示列表的第一个元素，以1表示列表的第二个元素，以此类推。也可以使用负数下标，以-1表示列表的最后一个元素，-2表示列表的倒数第二个元素，以此类推。可用版本&gt;=1.0.0。</p>
</li>
<li><p>lrem：lrem key count value；依据参数count的值，移除列表中与参数value相等的元素。返回被移除元素的数量。可用版本&gt;=1.0.0。</p>
<p>count的值可以是以下几种情况：</p>
<ul>
<li>count &gt; 0：从表头开始向表尾搜索，移除与value相等的元素，数量为count；</li>
<li>count &lt; 0：从表尾向表头搜索，移除与value相等的元素，数量为count的绝对值。</li>
<li>count = 0：移除表中所有与value相等的值。</li>
</ul>
</li>
<li><p>lset：lset key index value；将列表key下标为index的元素的值设置为value。当index参数超出范围，或对一个空列表(key不存在)进行lset时，返回一个错误。操作成功返回ok，否则返回错误信息。可用版本&gt;=1.0.0。</p>
</li>
<li><p>ltrim：ltrim key start stop；对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间内的元素都将被删除。命令执行成功返回ok。可用版本&gt;=1.0.0。</p>
</li>
<li><p>rpop：rpop key；移除并返回列表key的尾元素。当key不存在时，返回nil。</p>
</li>
<li><p>rpoplpush：rpoplpush source destination；该命令在一个原子时间内执行两个操作：</p>
<ul>
<li>将列表source中的最后一个元素(尾元素)弹出，返回给客户端。</li>
<li>将source弹出的元素插入到列表destination，作为列表destination的头元素。</li>
</ul>
<p>如果source不存在，返回nil，并不执行其他动作。如果source和destination相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的反转。可用版本&gt;=1.2.0。</p>
</li>
<li><p>rpush：rpush key value [value …]；将一个或多个值value插入列表key的表尾(最右边)。如果有多个value值，那么各个value值按从左到右的顺序依次插入到表尾。rpush执行后，返回列表的长度。可用版本&gt;=1.0.0。</p>
</li>
<li><p>rpushx：rpushx key value；将值value插入列表key的表尾，当且仅当key存在并且是一个列表。当key不存在时，rpushx命令什么也不做。rpushx执行成功后，返回列表的长度。可用版本&gt;=2.2.0。</p>
</li>
</ol>
<h3 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h3><p>哈希可以存储多个键值对之间的映射，和字符串一样，哈希存储的值既可以是字符串又可以是数字值。</p>
<h4 id="内部数据结构-2"><a href="#内部数据结构-2" class="headerlink" title="内部数据结构"></a>内部数据结构</h4><p>哈希类型的内部数据结构可以是ziplist或者hashtable。当哈希保存的所有键值对的键和值得字符串大小都小于64字节，并且键值对的数量小于512个时，底层将会采用ziplist存储结构，否则将采用hashtable存储结构。在redis中，hashtable有3层结构，dict -&gt; dictht -&gt; dictEntry，源码在<code>dict.h</code>中。</p>
<p><strong>dictEntry（哈希节点）</strong></p>
<p>管理一个key-value，同时保留同一个桶中相邻元素的指针，用户维护哈希桶的内部链表，结构定义如下：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictEntry <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        uint64_t u64<span class="token punctuation">;</span>
        int64_t s64<span class="token punctuation">;</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因为value有多种类型，所以value用了union来存储</span>
    <span class="token keyword">struct</span> dictEntry <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一个节点的地址，用来处理冲突，所以分配到同一个索引的元素通过next指针链接起来形成链表</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span>
</code></pre>
<p><strong>dictht（哈希表）</strong> </p>
<p>实现一个hashtable会用一个buckers存放dictEntry地址，一般情况下通过hash(key) % len得到的值就是buckers的索引，这个值决定了dictEntry节点的存放位置，<code>dict.h</code>中的dictht结构中table就是buckers的地址。</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictht <span class="token punctuation">{</span>
    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//buckets的地址</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//buckerts的大小，总保持为2^n</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//掩码，用来技术hash值对应的buckers索引</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前dictht有多少个dictEntry节点</span>
<span class="token punctuation">}</span> dictht<span class="token punctuation">;</span>
</code></pre>
<p><strong>dict（字典）</strong>                                                                           </p>
<p>dictht实际上就是hash表的核心，但是只有一个dictht还不够，比如rehash、遍历hash等操作，所以redis定义了 一个叫dict的结构以支持字典的各种操作，当dictht需要扩容/缩容时，用来管理dictht的迁移，以下是它的数据结构:</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dict <span class="token punctuation">{</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//dictType里存放的是工具函数的指针</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存type中某些函数需要作为参数的数据</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//维护两个dictht，ht[0]平时用，ht[1]rehash时用</span>
    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//当前rehash到buckerts的哪个索引位置，-1表示非rehash状态</span>
    <span class="token keyword">int</span> iterators<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//安全迭代器的计数</span>
<span class="token punctuation">}</span> dict<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//工具函数</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictType <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>hashFunction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>keyDup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>valDup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>keyCompare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>keyDestructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>valDestructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictType<span class="token punctuation">;</span>
</code></pre>
<p><strong>dict的结构图</strong>：</p>
<p><img src="/2019/03/20/RedisInAction/dict.png" alt></p>
<p><strong>哈希算法</strong></p>
<p>当要讲一个新的键值对添加到dict里面时，程序需要先根据键计算出哈希值和索引值，然后在根据索引值将键值对的哈希表节点放到哈希数组的指定索引上面。</p>
<pre class=" language-tex"><code class="language-tex">#使用dict设置的哈希函数，计算key的哈希值
hash = dict -> type -> hashFunction(key);

#使用哈希表的sizemask属性和哈希值，计算出索引值；根据情况不同，ht[x]可以是ht[0]或ht[1]
index = hash & dict -> hx[x].sizemask;

</code></pre>
<p>Redis使用<strong>MurmurHash2</strong>算法来计算键的哈希值。<strong>MurmuhHash算法</strong>最初由Austin Appleby于2008年发明，这个算法的优点在于即使输入的键是由规律的，算法仍能给出一个很好的随机分布行，并且算法的计算速度也很快。</p>
<p><strong>解决哈希冲突</strong></p>
<p>当有两个或两个以上的键被分配到哈希表数组的同一个索引上面时，就称这些键发生了冲突（conllision）。Redis的哈希类型使用<strong>链地址法</strong>来解决冲突，每个哈希节点都有一个next指针，多个哈希节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突问题。</p>
<p><strong>Rehash</strong></p>
<p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或减少，为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表保存的键值对数量大多或太少时，都需要对哈希表的大小进行相应的扩展或缩小。</p>
<p>扩展和缩小哈希表的工作可以通过执行rehash(重新散列)操作来完成，Redis对字典的哈希表执行rehash的步骤如下：</p>
<ul>
<li><p>为字典的ht[1]哈希表分配内存空间，这个哈希表的空间大小取决于要执行的操作依据ht[0]哈希表包含的键值对的数量(即ht[0].used属性的值)。</p>
<ul>
<li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n（2的n次方）；</li>
<li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n；</li>
</ul>
</li>
<li><p>将保存在ht[0]中的所有键值对rehash到ht[1]上面。</p>
</li>
<li>当ht[0]包含的所有键值对都迁移到了ht[1]之后，就把ht[0]置为空表，释放ht[0]，然后将ht[1]设置为ht[0]，并为ht[1]新建一个空的哈希表，为下次rehash做准备。</li>
</ul>
<h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><ol>
<li><strong>hdel</strong>：hdel key field [field …]；删除哈希表的一个或多个指定域，不存在的域将被忽略。返回被成功删除的域的数量。可用版本&gt;=2.0.0。</li>
<li><strong>hexists</strong>：hexists key field；查看哈些表key中，给定的field是否存在。如果存在，返回1；如果哈希表不含有给定域，或key不存在，返回0。可用版本&gt;=2.0.0。</li>
<li><strong>hget</strong>：hget key field；返回哈希表key中给定域field的值。如果给定的域不存在或是给定key不存在时，返回nil。可用版本&gt;=2.0.0。</li>
<li><strong>hgetall</strong>：hgetall key；返回哈希表中所有的域和值。若key不存在，返回空列表。可用版本&gt;=2.0.0。</li>
<li><strong>hincrby</strong>：hincrby key field increment；为哈希表key中的域field的值加上增量increment。增量也可以是负数，相当于对给定域进行减法操作。如果key不存在，一个新的哈希表被创建并执行hincrby命令。如果域field不存在，那么在执行命令前，域的值被初始化为0。对一个存储字符串值得域field执行hincrby命令，会返回错误。可用版本&gt;=2.0.0。</li>
<li><strong>hincrbyfloat</strong>：hincrbyfloat key field increment；为哈希表key中的field加上浮点数增量Increment。如果哈希表中没有域field，那么hincrbyfloat会先将域field的值设为0，然后再执行加法操作。可用版本&gt;=2.6.0。</li>
<li><strong>hkeys</strong>：hkeys key；返回哈希表key中的所有域。可用版本&gt;=2.0.0。</li>
<li><strong>hlen</strong>：hlen key；返回哈希表key中域的数量。当key 不存在时返回0。可用版本&gt;=1.0.0。</li>
<li><strong>hmget</strong>：hmget key field [field …]；返回哈希表key中，一个或多个给定域的值。如果给定的域不存在于哈希表，那么返回一个nil值。可用版本&gt;=2.0.0。</li>
<li><strong>hmset</strong>：hmset key field value [field value …]；同时将多个field-value设置到哈希表key中。可用版本&gt;=2.0.0。</li>
<li><strong>hset</strong>：hset key field value；将哈希表key中的域field的值设为value。如果key不存在，一个新的哈希表被创建并进行hset操作。可用版本&gt;=2.0.0。</li>
<li><strong>hsetnx</strong>：hsetnx key field value；将哈希表key中的域field的值设置为value，当且仅当域field不存在。设置成功，返回1；如果给定域已经存在斌别没有操作被执行，返回0。可用版本&gt;=2.0.0。</li>
<li><strong>hvals</strong>：hvals key；返回哈希表key中所有域的值。返回一个包含哈希表中所有值的表；如果key不存在，返回一个空表。可用版本&gt;=2.0.0。</li>
<li><strong>hscan</strong>：hsan key cursor [match pattern] [count count]；</li>
</ol>

            </div>
            <hr>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="https://lanchunqiu.github.io" class="b-link-green">lanchunqiu.github.io</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2019/03/20/RedisInAction/" class="b-link-green">Redis实战</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/03/23/SerializeAndDeserializeBinaryTree/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="序列化和反序列化一个二叉树">
                        
                        <span class="card-title">序列化和反序列化一个二叉树</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">题目描述序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-03-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/二叉树/" class="post-category" target="_blank">
                                    二叉树
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/" target="_blank">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/LeetCode/" target="_blank">
                        <span class="chip bg-color">LeetCode</span>
                    </a>
                    
                    <a href="/tags/二叉树/" target="_blank">
                        <span class="chip bg-color">二叉树</span>
                    </a>
                    
                    <a href="/tags/序列化/" target="_blank">
                        <span class="chip bg-color">序列化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/03/17/SearchIn2DArray/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="二维数组中的查找">
                        
                        <span class="card-title">二维数组中的查找</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。请完成一个函数，输入这样的一个二维数组和一个整数，判断整数是否在二维数组中。

解法一：暴力解法暴力解法是最容易想到</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-03-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/算法/" class="post-category" target="_blank">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/" target="_blank">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/算法/" target="_blank">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">





</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>