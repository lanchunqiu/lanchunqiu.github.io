<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="JVM原理, lanchunqiu.github.io">
    <meta name="description" content="对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个创建对象操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由于虚拟机管理内存这一切看起来很美好。不过，也正是因为Java程序员把内存控制权交">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>JVM原理 | lanchunqiu.github.io</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">lanchunqiu.github.io</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">lanchunqiu.github.io</div>
        <div class="logo-desc">
            
            欢迎访问我的博客小站
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/lanchunqiu" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/lanchunqiu" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/16.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        JVM原理
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JVM/" target="_blank">
                                <span class="chip bg-color">JVM</span>
                            </a>
                        
                            <a href="/tags/Java虚拟机/" target="_blank">
                                <span class="chip bg-color">Java虚拟机</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JVM/" class="post-category" target="_blank">
                                JVM
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-03-03
                </div>

                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个创建对象操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由于虚拟机管理内存这一切看起来很美好。不过，也正是因为Java程序员把内存控制权交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将成为一项异常艰辛的工作。后面讲从概念上介绍Java虚拟机内存的各个区域。</p>
<h2 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分成若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而创建和销毁。根据<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/index.html" target="_blank" rel="noopener">《Java虚拟机规范（Java SE 7 版）》</a>的规定，Java虚拟机所管理的内存包括以下几个运行时数据区域，如下图：</p>
<p><img src="/2019/03/03/jvm-principle/JavaRuntimeDataArea.png" alt></p>
<p>运行时数据区域包括：方法区、堆、虚拟机栈、本地方法栈、程序计数器；</p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><p><strong>程序计数器</strong>是一块较小的内存空间，它可以看作是<strong>当前线程</strong>所执行的字节码的行号指示器。字节码指令中的分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（多核处理器的一个核心）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，所以程序计数器为“线程私有”的内存。</p>
<p>此内存区域是唯一一个在Java虚拟机规范只能够没有规定任何OutOfMemoryError情况的区域。</p>
<h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h3><p><strong>虚拟机栈</strong>也是线程私有的内存区域，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。每个方法从调用直至执行完成的过程，就时对应着一个栈帧在虚拟机栈总入栈到出栈的过程。</p>
<p>局部变量表存放了在编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）和对象引用（reference类型）。局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>在Java虚拟机规范中，对这个区域规定了2种异常情况：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</li>
<li>如果虚拟机栈可以动态扩展（当前大部分的虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常。</li>
</ul>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h3><p><strong>本地方法栈</strong>与虚拟机栈的作用非常类似，它们之间的区别不过是虚拟机栈是为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h3><p><strong>堆</strong>是Java虚拟机所管理的内存中最大的一块。堆是被所以线程所共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例和数组都在这里分配内存。</p>
<p>堆是垃圾收集器管理的主要区域。</p>
<p>从内存的回收角度来看，由于现在的收集器基采用了分代收集算法，所以堆还可以化分为：新生代和老年代。新生代可以再分为Eden空间、From Survivor空间、To Survivor空间。</p>
<p>从内存分配的角度来看，线程共享的堆中可能划分出多个线程私有分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<p>无论如何划分，都与存放内容无关，无论哪个区域，存储的都是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存。</p>
<p>根据Java虚拟机规范的规定，堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可，就像磁盘空间一样。既可以是固定大小的，也可以是扩展的，具体可以通过-Xmx和-Xms控制。如果堆中没有内存完成实例分配，并且也无法扩展时，将会抛出OutOfMemoryError异常。</p>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h3><p><strong>方法区</strong>与堆一样是所有线程共享的内存区域，它用于存储已经被虚拟机加载的<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译后的代码</strong>等数据。理论上属于运行时数据区的一部分，为了和堆（Heap）区分，它有一个别名叫做非堆（Non-Heap）。</p>
<p>这个区域可以选择不进行内存回收，该区域回收的目标主要是针对常量池回收和对类型的卸载。内存不足时会抛出OutOfMemoryError异常。</p>
<p><strong>运行时常量池</strong>：它是方法区的一部分。Class的版本、字段、方法、接口等，以及编译期生成的各种字面量、符号引用，这部分内容将在类加载后存放到运行时常量池中。</p>
<h2 id="二、直接内存"><a href="#二、直接内存" class="headerlink" title="二、直接内存"></a>二、直接内存</h2><p><strong>直接内存（Direct Memory）</strong>并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但也会抛出OutOfMemoryError异常。</p>
<p>在JDK1.4中新加入了NIO（New Input/Output），引入了一种基于通道（Channel）与缓冲区（Buffer）的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因此避免了Java堆和Native堆中来回复制数据。</p>
<p>直接内存的分配不受Java堆大小的限制，但是会受到本机总内存大小和处理器寻址空间的限制。</p>
<h2 id="三、对象的内存布局"><a href="#三、对象的内存布局" class="headerlink" title="三、对象的内存布局"></a>三、对象的内存布局</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）</strong>、<strong>对齐填充（Padding）</strong>。</p>
<h3 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h3><p>对象头包括两部分信息：</p>
<ul>
<li><p>第一部分为Mark Word，用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程吃药的锁、偏向线程ID、偏向时间戳等。Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么MarkWord的32位空间中的25位用于存储对象哈希码，4位用于存储对象分代年龄，2位用于存储锁标志位，1位固定为0。</p>
<p><img src="/2019/03/03/jvm-principle/MarkWord.png" alt></p>
<p>其中<strong>无锁</strong>和<strong>偏向锁</strong>的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态。</p>
<p>JDK1.6对锁进行了优化，以后的版本在处理同步锁时存在锁升级的概念，JVM对于同步锁的处理是从<strong>偏向锁</strong>开始的，随着竞争越来越激烈，处理方式从<strong>偏向锁</strong>升级到<strong>轻量级锁</strong>，最终升级到<strong>重量级锁</strong>。</p>
<p>JVM一般是这样使用锁和Mark Word的：</p>
<ul>
<li><p>（1）当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0，表示<strong>无锁</strong>。</p>
</li>
<li><p>（2）当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程ID，表示进入<strong>偏向锁</strong>状态。</p>
</li>
<li><p>（3）当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程ID就是线程A自己的ID，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</p>
</li>
<li><p>（4）当另一个线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程ID记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程ID改为线程B的ID，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤（5）。</p>
</li>
<li><p>（5）偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为<strong>轻量级锁</strong>。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤（6）。</p>
</li>
<li><p>（6）轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤（7）。</p>
</li>
<li><p>（7）自旋锁重试之后如果抢锁依然失败，同步锁会升级至<strong>重量级锁</strong>，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</p>
</li>
</ul>
</li>
<li><p>第二部分是类型指针，它是指向<strong>方法区</strong>对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分存储数组长度。</p>
</li>
</ul>
<p>###实例数据（Instance Data）</p>
<p>实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>
<h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。</p>
<h2 id="四、对象的访问定位"><a href="#四、对象的访问定位" class="headerlink" title="四、对象的访问定位"></a>四、对象的访问定位</h2><p>建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置。所以对象的访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。</p>
<h3 id="句柄方式访问"><a href="#句柄方式访问" class="headerlink" title="句柄方式访问"></a>句柄方式访问</h3><p>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<p><img src="/2019/03/03/jvm-principle/ObjectHandlerAccess.png" alt></p>
<p>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象时非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要改变。</p>
<h3 id="直接指针式访问"><a href="#直接指针式访问" class="headerlink" title="直接指针式访问"></a>直接指针式访问</h3><p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的地址信息，而reference存储的直接就是对象地址。</p>
<p><img src="/2019/03/03/jvm-principle/ObjectDirectPointerAccess.png" alt></p>
<p>使用直接地址访问方式的最大好处就是速度快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的指向成本。就Hotspot虚拟机而言，它是使用的第二种方式进行访问的。</p>
<h2 id="五、内存区域控制参数及对应溢出异常"><a href="#五、内存区域控制参数及对应溢出异常" class="headerlink" title="五、内存区域控制参数及对应溢出异常"></a>五、内存区域控制参数及对应溢出异常</h2><p>在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时数据区域都有可能发生OutOfMemoryError异常（以下简称OOM）。</p>
<p>在开发过程中或程序运行过程中每次遇到OOM异常或StackOverflowError异常或GC异常时，我们需要根据异常信息来快速判断时哪个区域的异常，知道怎样的代码可能会导致这些区域的异常，以及出现这些异常后改怎么处理。下面就来介绍一下每个区域可能抛出的异常类型、发生异常的场景以及内存区域对象的参数。</p>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>常用参数：</p>
<ul>
<li><p>-Xms：堆最小值</p>
</li>
<li><p>-Xmx：堆最大值</p>
</li>
<li><p>其他：-XX:+HeapDumpOnOutOfMemoeryError可以让虚拟机在出现内存溢出异常时Dump当前的内存堆转储快照一般事后进行分析。</p>
</li>
</ul>
<p>例：-Xms128M -Xmx=128M</p>
<p>通常将-Xmx和-Xms设置为一样的大小来减少gc的次数，堆内存不足时抛出OOM异常。</p>
<p>Java堆内存的OOM异常时实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。</p>
<p>要解决着区域的异常，一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否必要的，也就要先分清楚到底是出现了内存泄漏还是内存溢出。</p>
<h3 id="栈内存（虚拟机栈和本地方法栈）"><a href="#栈内存（虚拟机栈和本地方法栈）" class="headerlink" title="栈内存（虚拟机栈和本地方法栈）"></a>栈内存（虚拟机栈和本地方法栈）</h3><p>常用参数：-Xss，例如：-Xss128K。</p>
<p>关于虚拟机栈和本地方法栈，在虚拟机规范中描述了两种异常：</p>
<ul>
<li><p>如果线程请求的栈深度大于虚拟机所允许最大深度，将抛出StackOverflowError异常；</p>
</li>
<li><p>如果虚拟机栈在扩展栈是无法申请足够的内存空间，则抛出OutOfMemoryError异常；</p>
</li>
</ul>
<h3 id="方法区内存"><a href="#方法区内存" class="headerlink" title="方法区内存"></a>方法区内存</h3><p>常用参数：</p>
<ul>
<li><p>-XX:PermSize方法区内存最小值</p>
</li>
<li><p>-XX:MaxPermSize方法区内存最大值</p>
</li>
</ul>
<p>例：-XX:PermSize=200M -XX:MaxPermSize=200M</p>
<p>异常类型：OutOfMemoryError</p>
<p>因为方法区用于存放加载的类信息、常量、静态变量、即时编译后的代码等数据，所以产生类过多就可能出方法区异常异常。当前的很多框架，例如Spring、Hibernate，在多类进行增强时，都会使用CGLib字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>常用参数：-XX:MaxDirectMemorySize，例如：-XX:MaxDirectMemorySize=100M。如果不指定则与堆的最大值相同。</p>
<p>异常：OutOfMemoryError</p>
<h2 id="六、垃圾收集算法"><a href="#六、垃圾收集算法" class="headerlink" title="六、垃圾收集算法"></a>六、垃圾收集算法</h2><h3 id="怎么确定对象可被回收"><a href="#怎么确定对象可被回收" class="headerlink" title="怎么确定对象可被回收"></a>怎么确定对象可被回收</h3><p>在堆里面存放Java中几乎所有的对象实例。垃圾收集器在对堆进行回收之前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”。</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不能在使用的。</p>
<p>客观地说，引用计数算法的实现很简单，判断效率也很高，在大部分情况下它都是一个不错的算法，也有一些著名的应用案例。但是，至少主流的Java虚拟机里面没有选用引用计数器算法来管理内存，其中主要的原因时它很难解决对象之间循环引用的问题。</p>
<p>举个简单的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGC</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span>  Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 这个成员属性的唯一意义就是占点内存，以便在GC日志中看情况是否内回收过
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bigSize <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        ReferenceCountingGC objA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ReferenceCountingGC objB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>
        objB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>

        objA <span class="token operator">=</span> null<span class="token punctuation">;</span>
        objB <span class="token operator">=</span> null<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//假设这行发生GC，objA和objB是否能被回收？</span>
        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">testGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在idea设置vm参数，让程序运行后打印GC日志，“-Xms50M -Xmx100M -XX:+PrintGCDetails -Xloggc:./gc.log”</p>
<p><img src="/2019/03/03/jvm-principle/idea-vm-params.png" alt></p>
<p>在输出的GC日志中可以看到“6679K-&gt;704K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>
<pre><code>0.188: [GC (System.gc()) [PSYoungGen: 6679K-&gt;704K(14848K)] 6679K-&gt;712K(49152K), 0.0010985 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.189: [Full GC (System.gc()) [PSYoungGen: 704K-&gt;0K(14848K)] [ParOldGen: 8K-&gt;596K(34304K)] 712K-&gt;596K(49152K), [Metaspace: 3074K-&gt;3074K(1056768K)], 0.0053940 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 14848K, used 256K [0x00000007bdf00000, 0x00000007bef80000, 0x00000007c0000000)
  eden space 12800K, 2% used [0x00000007bdf00000,0x00000007bdf40190,0x00000007beb80000)
  from space 2048K, 0% used [0x00000007beb80000,0x00000007beb80000,0x00000007bed80000)
  to   space 2048K, 0% used [0x00000007bed80000,0x00000007bed80000,0x00000007bef80000)
 ParOldGen       total 34304K, used 596K [0x00000007b9c00000, 0x00000007bbd80000, 0x00000007bdf00000)
  object space 34304K, 1% used [0x00000007b9c00000,0x00000007b9c953c8,0x00000007bbd80000)
 Metaspace       used 3086K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 335K, capacity 388K, committed 512K, reserved 1048576K
</code></pre><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>在主流的商用程序语言（Java、C#）的主流实现中，都是通过可达性分析来判定对象是否存活的。可达性分析算法的基本思路就是通过一些列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图伦的话来说，就是从GC Roots 到这个对象不可达）时，则证明此对象时不可用的。ReachabilityAnalysis</p>
<p><img src="/2019/03/03/jvm-principle/ReachabilityAnalysis.png" alt></p>
<p>在Java语言中，可作为GC Roots的对象包括下面4种：</p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象；</p>
</li>
<li><p>方法区中类静态属性引用的对象；</p>
</li>
<li><p>方法区中常量引用的对象；</p>
</li>
<li><p>本地方法栈中（即一般说的Native方法）引用的对象。</p>
</li>
</ul>
<p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用（Strong Reference）</strong>、<strong>软引用（Soft Reference）</strong>、<strong>弱引用（Weak Reference）</strong>、<strong>虚引用（Phantom Reference）</strong>4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li><p><strong>强引用</strong>就是指在程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
</li>
<li><p><strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference来实现软引用。</p>
</li>
<li><p><strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用还要弱一些，被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</p>
</li>
<li><p><strong>虚引用</strong>也成为幽灵引用或虚幻引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</p>
</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最基础的收集算法是<strong>“标记-清除”（Mark-Sweep）</strong>算法，算法分为“标记”和“清除”两个阶段：标记阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。其他的收集算法都是基于标记清除算法基础上进行改进得到的。</p>
<p>主要缺点：</p>
<p>一个是效率问题，标记和清除两个过程的效率都不高；</p>
<p>另一个是空间问题，标记清除之后会产生大量不连续的内存碎片。</p>
<p><img src="/2019/03/03/jvm-principle/MarkSweep.png" alt></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题，一种称为<strong>“复制”（Copying）</strong>的收集算法出现了，它将可用的内存容量划分大小相等的两块，每次只使用其中的一块。当着一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。这种算法的代价就是将内存缩小为原理的一半，未免也太高了一点。</p>
<p><img src="/2019/03/03/jvm-principle/Copying.png" alt></p>
<p>在商用的虚拟中使用该算法回收新生代，由研究表明，新生代中的对象98%是“朝生夕死”的，并不需要按照1:1的比例来划分内存，而是将内存分为一块较大的<strong>Eden空间</strong>和两块小的<strong>Survivor空间</strong>，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。</p>
<p>当然98%的对象可以回收这只是一般场景下的数据，我们没有办法保证每次回收都只有不到10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<p>优点：</p>
<p>比较标记清除算法，避免了回收造成的内存碎片；</p>
<p>缺点：</p>
<p>以牺牲空间为代价，复制也有一定的效率和空间成本。</p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>前面的讲解的复制算法在对象存活率较高时就需要进行多次的复制操作，效率将会降低，更关键的是如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的的内存中所以对象都100%存活的极端情况，所以在<strong>老年代</strong>一般不直接采用这种算法。</p>
<p>更加老年代对象存活率高的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程任然与“标记-清除”算法一样，但后面步骤不在是直接对可回收对象进行清理，而是让所以存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="/2019/03/03/jvm-principle/MarkCompact.png" alt></p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前商业虚拟机的懒觉收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般把内存划分为新生代和老年代2块，这样就可以根据各个年代的特点采用最合适的收集算法。在新生代中，每次垃圾收集时都发现有大量的对象死去，只有少量存活，那就选用户<strong>复制算法</strong>。而老年代中因为对象存活率高，没有额外的空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
<h2 id="七、垃圾收集器"><a href="#七、垃圾收集器" class="headerlink" title="七、垃圾收集器"></a>七、垃圾收集器</h2><p>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。</p>
<p><img src="/2019/03/03/jvm-principle/GarbageCollector.png" alt></p>
<h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1.Serial 收集器"></a>1.Serial 收集器</h3><p>特点：</p>
<p>（1）新生代收集器，可以和Serial Old、CMS组合使用；</p>
<p>（2）采用复制算法；</p>
<p>（3）使用单线程进行垃圾回收，回收时会导致Stop The World，用户进程停止；</p>
<p>（4）Client模式新生代收集器；</p>
<p><img src="/2019/03/03/jvm-principle/Serial.png" alt></p>
<h3 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2.ParNew 收集器"></a>2.ParNew 收集器</h3><p>特点：</p>
<p>（1）新生代收集器，可以和Serial Old、CMS组合使用；</p>
<p>（2）采用复制算法；</p>
<p>（3）使用多线程进行垃圾回收，回收时会导致Stop The World，其它策略和Serial一样；</p>
<p>（4）许多虚拟机Server模式的新生代收集器；</p>
<p><img src="/2019/03/03/jvm-principle/ParNew.png" alt></p>
<h3 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3.Parallel Scavenge 收集器"></a>3.Parallel Scavenge 收集器</h3><p>特点：</p>
<p>（1）新生代收集器，可以和Serial Old、Parallel组合使用，不能和CMS组合使用；</p>
<p>（2）采用复制算法；</p>
<p>（3）使用多线程进行垃圾回收，回收时会导致Stop The World；</p>
<p>（4）关注吞吐量，吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）；</p>
<p><img src="/2019/03/03/jvm-principle/ParallelScavenge.png" alt></p>
<h3 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4.Serial Old 收集器"></a>4.Serial Old 收集器</h3><p>特点：</p>
<p>（1）老年代收集器，可以和所有的年轻代收集器组合使用，Serial收集器的老年代版本；</p>
<p>（2）标记-整理算法，会对垃圾回收导致的内存碎片进行整理；</p>
<p>（3）使用单线程进行垃圾回收，回收时会导致Stop The World，用户进程停止；</p>
<p><img src="/2019/03/03/jvm-principle/SerialOld.png" alt></p>
<h3 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5.Parallel Old 收集器"></a>5.Parallel Old 收集器</h3><p>特点：</p>
<p>（1）年老代收集器，只能和Parallel Scavenge组合使用，Parallel Scavenge收集器的年老代版本，Stop The World；</p>
<p>（2）多线程，采用标记-整理算法，会对垃圾回收导致的内存碎片进行整理；</p>
<p>（3）关注吞吐量的系统可以将Parallel Scavenge + Parallel Old组合使用；</p>
<p><img src="/2019/03/03/jvm-principle/ParallelOld.png" alt></p>
<h3 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6.CMS 收集器"></a>6.CMS 收集器</h3><p>特点：</p>
<p>（1）年老代收集器，可以和Serial、ParNew组合使用；</p>
<p>（2）采用标记-清除算法，可以通过设置参数在垃圾回收时进行内存碎片的整理；</p>
<p>（3）CMS是并发算法，表示垃圾回收和用户进行同时进行，但是不是所有阶段都同时进行，在初始标记、重新标记阶段还是需要Stop the World；</p>
<p>（4）CMS垃圾回收分这四个阶段，三次标记一次回收：</p>
<ul>
<li><p><strong>初始标记</strong>，Stop the World，标记一下GC Roots能直接关联到的对象，速度快；</p>
</li>
<li><p><strong>并发标记</strong>，GC Roots Tracing，时间长，不停止用户进程；</p>
</li>
<li><p><strong>重新标记</strong>，Stop the World，修正并发标记期间因用户程序继续运行导致标记变动的那一部分对象的标记记录，时间长，但远比并发标记时间短；</p>
</li>
<li><p><strong>并发清除</strong>，清除的同时用户进程会导致新的垃圾，时间长；</p>
</li>
</ul>
<p>5、适合于对响应时间要求高的系统，以最短回收停顿时间为目标；</p>
<p>缺点：</p>
<ul>
<li><p>对CPU资源非常敏感，并发且维护用户进程的代价；</p>
</li>
<li><p>无法处理浮动垃圾，清除时产生新垃圾；</p>
</li>
<li><p>由于使用标记清除，故有空间碎片；</p>
</li>
</ul>
<p><img src="/2019/03/03/jvm-principle/CMS.png" alt></p>
<h3 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7.G1 收集器"></a>7.G1 收集器</h3><p>特点：</p>
<p>（1）并行并发，使用多个CPU缩短STW的时间；</p>
<p>（2）分代收集，不需要其他收集器配合也能独立管理堆；</p>
<p>（3）空间整合，整体基于标记整理算法，局部两个Region基于复制；</p>
<p>（4）可预测停顿，可以指定时间段M内GC过程时间不超过N；</p>
<p>（5）较低停顿，停顿时间更加可控可预测；</p>
<p>特殊点：</p>
<ul>
<li><p>新生代和老年代不再物理隔离，都是一部分Region的集合，将堆分为大小相等的Region；</p>
</li>
<li><p>G1跟踪各个Region垃圾的价值大小以及回收需要时间维护一个Region优先列表，每次先回收价值最大的Region，这是G1-Garbage First名字的由来；</p>
</li>
</ul>
<p>G1运作分四个阶段，三次标记一次回收：初始标记，并发标记，最终标记，筛选回收；</p>
<p><img src="/2019/03/03/jvm-principle/G1.png" alt></p>
<h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseSerialGC</td>
<td>虚拟机运行在Client模式下的默认值，添加此配置后，使用Serial+Serial Old收集器组合进行内存回收。</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>添加此配置后，使用ParNew+SerialOld收集器组合进行内存回收。</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>添加此配置后，使用ParNew+CMS+SerialOld收集器组合进行内存回收。Serial Old手机器作为CMS收集器Concurrent Mode Failure失败后的备用手机器。</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>虚拟机运行在Sever模式下的默认值，添加此配置后，使用Parallel  Scavenge  + Serial Old（PS MarkSweep）收集器组合进行内存回收</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>添加此配置后，使用Parallel Scavenge + Parallel Old收集器进行内存回收。</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor = 8:1</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄。每个对象在坚持过一次MinorGC之后，年龄就增加1，当超过这个参数值是就进入老年代</td>
</tr>
<tr>
<td>-XX:UseAdaptiveSizePolicy</td>
<td>动态调整Java堆中各个区域的大小以及进入老年代的年龄</td>
</tr>
<tr>
<td>-XX:HandlePromotionFailure</td>
<td>是否允许分配担保失败，即老年代的剩余空间不足以应对新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td>
</tr>
<tr>
<td>-XX:ParalelGCThreads</td>
<td>设置并行GC时进行内存回收的线程数</td>
</tr>
<tr>
<td>-XX:GCTimeRatio</td>
<td>GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>-XX:UseCMSCompacatAtFullCollection</td>
<td>实质CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效</td>
</tr>
<tr>
<td>-XX:CMSFullGCsBeforeCompaction</td>
<td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</td>
</tr>
</tbody>
</table>
<p>其他参数：</p>
<p>-verbose:gc或者-XX:+PrintGC，获取gc信息</p>
<p>-XX:+PrintGCDetails，获取更加纤细的gc信息</p>
<p>-XX:+PrintGCTimeStamps， 获取GC的频率和间隔</p>
<p>-XX:+PrintHeapAtGC，获取堆的使用情况</p>
<p>-XXloggc:D:\gc.log，指定GC日志的保存路径</p>
<h3 id="调优策略"><a href="#调优策略" class="headerlink" title="调优策略"></a>调优策略</h3><ul>
<li><p><strong>对象优先在新生代Eden区域分配</strong>：由于FullGC/MajorGC（发生在老年代），成本远比MinorGC（发生在新生代）要大的多，所以给应用分配一个合理的新生代空，尽量将对象优先分配到新生代，减少Full GC的频率。</p>
</li>
<li><p><strong>大对象直接进入老年代</strong>：将大对象（例如长字符串以及数组）直接分配到老年代，保持新生代对象的结构的完整行，以提高GC效率。可以通过-XX:PretenureSizeThreshold参数设置对象进入老年代的阀值。</p>
</li>
<li><p><strong>长期存活的对象直接进入老年代</strong>：对象晋升老年代的年龄阀值，可以通过参数-XX:MaxTenuringThreshold来设置。</p>
</li>
<li><p><strong>稳定的堆大小</strong>：稳定的堆大小时对垃圾回收有利的，把-Xms和-Xmx的大小设置一致。</p>
</li>
<li><p><strong>更加情况选择合适的收集器</strong>：吞吐量优先，尽可能减少系统执行垃圾回收的总时间，故采用并行收集器；低停顿：使用CMS收集器，同时减少Full GC的次数。</p>
</li>
</ul>
<p>​     </p>
<p><em>文章内容主要摘自《深入理解Java虚拟机-JVM高级特性与最佳实践》</em></p>

            </div>
            <hr>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="https://lanchunqiu.github.io" class="b-link-green">lanchunqiu.github.io</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2019/03/03/jvm-principle/" class="b-link-green">JVM原理</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-dot-circle-o"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2019/03/03/jvm-principle/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="JVM原理">
                        
                        <span class="card-title">JVM原理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个创建对象操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由于虚拟机管理内存这一切看起来很美好。不过，也正是因为Java程序员把内存控制权交</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-03-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JVM/" class="post-category" target="_blank">
                                    JVM
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JVM/" target="_blank">
                        <span class="chip bg-color">JVM</span>
                    </a>
                    
                    <a href="/tags/Java虚拟机/" target="_blank">
                        <span class="chip bg-color">Java虚拟机</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/03/02/JumpGame/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="跳跃游戏">
                        
                        <span class="card-title">跳跃游戏</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。LeetCode
示例1
输入: [2,3,1,1,4]
输出: true
解释: 从位置 0 到 1 跳 </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-03-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/算法/" class="post-category" target="_blank">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/" target="_blank">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/算法/" target="_blank">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                    <a href="/tags/LeetCode/" target="_blank">
                        <span class="chip bg-color">LeetCode</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">





</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>